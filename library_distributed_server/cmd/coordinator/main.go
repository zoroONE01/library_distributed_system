// Package main Distributed Transaction Coordinator API
//
// This service coordinates distributed transactions across multiple library sites
// using the Two-Phase Commit (2PC) protocol for academic demonstration.
//
// @title Distributed Transaction Coordinator API
// @version 1.0
// @description Coordinator service for distributed transactions in the library management system
// @termsOfService N/A
//
// @contact.name API Support
// @contact.email dev@library.com
//
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
//
// @host localhost:8080
// @BasePath /
//
// @schemes http https
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"library_distributed_server/internal/auth"
	"library_distributed_server/internal/config"
	"library_distributed_server/internal/distributed"
	"library_distributed_server/internal/models"
	"library_distributed_server/pkg/database"
	"library_distributed_server/pkg/utils"

	_ "library_distributed_server/docs/coordinator" // docs is generated by Swag CLI, you have to import it.

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

type CoordinatorHandler struct {
	coordinator *distributed.TwoPhaseCommitCoordinator
}

type TransferBookRequest struct {
	MaQuyenSach string `json:"maQuyenSach" binding:"required" example:"QS001" validate:"required"` // Book copy ID to transfer
	FromSite    string `json:"fromSite" binding:"required" example:"Q1" validate:"required"`       // Source site ID
	ToSite      string `json:"toSite" binding:"required" example:"Q3" validate:"required"`         // Destination site ID
}

func NewCoordinatorHandler(coordinator *distributed.TwoPhaseCommitCoordinator) *CoordinatorHandler {
	return &CoordinatorHandler{
		coordinator: coordinator,
	}
}

// TransferBook handles POST /coordinator/transfer-book
// Implements distributed book transfer using Two-Phase Commit protocol
// @Summary Transfer book between sites using 2PC
// @Description Transfer a book copy from one site to another using distributed transaction coordination
// @Tags Coordinator
// @Accept json
// @Produce json
// @Param request body TransferBookRequest true "Book transfer request"
// @Success 200 {object} models.TransferBookResponse "Book transferred successfully"
// @Failure 400 {object} models.ErrorResponse "Invalid request format"
// @Failure 500 {object} models.ErrorResponse "Failed to transfer book"
// @Router /coordinator/transfer-book [post]
func (h *CoordinatorHandler) TransferBook(c *gin.Context) {
	var req TransferBookRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Error:   "Invalid request format",
			Details: err.Error(),
		})
		return
	}

	// Validate sites
	if req.FromSite == req.ToSite {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Error: "Source and destination sites cannot be the same",
		})
		return
	}

	// Use stored procedure approach (which already implements 2PC)
	err := h.coordinator.TransferBookUsingStoredProcedure(req.MaQuyenSach, req.FromSite, req.ToSite)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Error:   "Failed to transfer book",
			Details: err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, models.TransferBookResponse{
		Message:     "Book transferred successfully using 2PC protocol",
		MaQuyenSach: req.MaQuyenSach,
		FromSite:    req.FromSite,
		ToSite:      req.ToSite,
		Protocol:    "Two-Phase Commit (2PC)",
		Coordinator: "Distributed Transaction Coordinator",
	})
}

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal("Failed to load configuration:", err)
	}

	// Override port for coordinator
	cfg.Server.Port = 8080

	authService := auth.NewAuthService(cfg.Auth.JWTSecret, cfg.Auth.TokenExpiry)
	coordinator := distributed.NewTwoPhaseCommitCoordinator(cfg)
	coordinatorHandler := NewCoordinatorHandler(coordinator)

	router := setupRouter(authService, coordinatorHandler)

	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", cfg.Server.Port),
		Handler:      router,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
		IdleTimeout:  cfg.Server.IdleTimeout,
	}

	go func() {
		log.Printf("Distributed Transaction Coordinator starting on port %d", cfg.Server.Port)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatal("Server failed to start:", err)
		}
	}()

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Println("Shutting down coordinator...")
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatal("Coordinator forced to shutdown:", err)
	}

	database.GetPool().CloseAll()
	log.Println("Coordinator exited")
}

func setupRouter(_ *auth.AuthService, coordinatorHandler *CoordinatorHandler) *gin.Engine {
	gin.SetMode(gin.ReleaseMode)
	router := gin.Default()

	// Add CORS middleware
	router.Use(utils.CORS())

	// Swagger endpoint
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// @Summary Health check
	// @Description Check if the coordinator service is running
	// @Tags Health
	// @Produce json
	// @Success 200 {object} models.HealthResponse "Coordinator service is healthy"
	// @Router /health [get]
	router.GET("/health", func(c *gin.Context) {
		c.JSON(200, models.HealthResponse{
			Status:    "healthy",
			Site:      "coordinator",
			Time:      time.Now(),
			Service:   "Distributed Transaction Coordinator",
			Protocols: []string{"Two-Phase Commit (2PC)"},
		})
	})

	// Coordinator APIs (typically used by managers or system administrators)
	coordinatorGroup := router.Group("/coordinator")
	{
		// Public endpoint for academic demonstration
		coordinatorGroup.POST("/transfer-book", coordinatorHandler.TransferBook)

		// Protected endpoints would require authentication in production
		// For academic purposes, we keep it simple
	}

	return router
}
